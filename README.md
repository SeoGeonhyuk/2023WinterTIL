# 2023WinterTIL
2023년 동계 모각소를 위한 TIL입니다.
# 20240119
# 1장-멀티스레딩

기존에 코드와 데이터로 저장되어 있던 프로그램이 실행되면 프로세스의 형태로 운영체제를 통해 관리되며, 이러한 프로세스는 메모리 위에 올려져 실행된다.

프로세스를 실행하기 전 컴파일러 된 부분에서 나오는 변수는 스택 부분에 올려진다.

프로세스를 통해 프로그램이 실행되면서 나오는 변수와 함수는 힙 부분에 올려진다.

프로세스가 여러 개 동시에 실행되고 있는 것을 멀티프로세싱이라고 한다.

프로세스에서는 여러 개의 스레드가 공존할 수 있으며, 이러한 스레드들은 힙을 통해 메모리를 공유한다. 하지만 스레드마다 스택을 가진다. 이러한 스택 내부에는 스레드에서 실행하는 함수의 로컬 변수들이 저장된다.

프로세스 하나를 메인 스레드 하나가 담당하는 것을 싱글스레드 모델

한 프로세스에 메인 스레드 뿐만 아니라, 부가적인 스레드들이 같이 해당 프로세스를 작동하는 것을 멀티스레딩이라고 한다.

이러한 멀티스레드를 사용할 때는 변수의 동기화를 유의해서 사용해야 한다.

다른 스레드로 인해서 변수의 값이 변경(race condition) 또는 메모리 주소값이 기존과 다르게 변경될 수도 있기 때문이다.

그래서 이러한 문제를 해결하기 위해 보통 스레드가 메모리를 참조하는 그러한 부분에 락을 걸어서 사용한다.

프로그램 실행 중 스레드가 변경되는 것을 컨텍스트 스위치라고 한다(이러한 컨텍스트 스위치는 CPU 코어의 개수보다 관리할 스레드의 개수가 많을 때 발생한다.)

이러한 컨텍스트 스위치는 언제 발생할지 알 수 없으므로 개발자의 멀티스레딩 의도대로 동작시키기 위해서 다양한 방법을 사용한다.

이러한 race condition이 발생하는 부분을 critical section이라고 하며, 이를 해결하기 위해서 뮤텍스, 이벤트, 세마포어 등을 활용한다.

컨텐션: 두 스레드가 동시에 한 데이터를 액세스하려고 하는 상황을 의미합니다. 두 스레드 중 하나 이상이 읽기 또는 쓰기를 할 때 뮤텍스로 잠금을 해서 보호하지 않으면 경쟁 상태가 발생하는 문제가 생깁니다. 또 뮤텍스로 잠금을 할 때는 한 스레드가 일을 하는 동안 다른 스레드가 모두 대기를 함으로써 병렬성이 사라지는 문제가 생깁니다. 이러한 컨텐션은 멀티스레드 프로그래밍에서 불가피합니다.

데드 락:서로의 스레드가 각각 다음에 참고해야 할 critical section 부분에 대한 락을 상대방이 가지고 있는 상태 이로 인해서 다음과 같은 문제가 발생할 수 있다.

1. CPU 사용량이 현저히 낮거나 0%입니다.
2. 클라이언트가 서버를 이용할 수 없습니다.

이러한 데드 락을 해결하기 위한 간단한 방법은 잠금 순서를 일관되게 정해두는 것이다.

A락, B락, C락이 있다면 순서를 A→B→C로 잠금 순서를 정하고 모든 스레드가 해당 방식으로 락을 거는 것이다.

예를 들어

B→C(o)

C→B(x)

A→B→C(o)

B→C→A(x)

가 된다.

락을 해제하는데는 순서가 상관없다.(B→A→C 등, 어떠한 순서로도 잠금해제를 해도 됨)

재귀 뮤텍스:한 스레드가 한 뮤텍스를 여러 번 잠금 해제 하는 것, 이렇게 여러 번 잠금을 할 경우, 잠금은 누적되며, 만약 잠금이 2번 중복되었을 경우 반드시 2번 해제해야 한다. 또한 재귀 뮤텍스는 잠금 순서의 규칙을 지키지 않아도 된다.

시리얼 병목:뮤텍스가 보호하는 영역이 너무 넓으면 스레드가 여럿이라 하더라도 하나일 때와 별반 차이가 없습니다. 여러 CPU가 각 스레드의 연산을 실행하여 동시 처리량을 올리는 것을 병렬성이라고 합니다. 그런데 어떤 이유로 이러한 병렬성이 제대로 나오지 않는 것, 즉 병렬로 실행되게 프로그램을 만들었는데 정작 한 CPU만 연산을 수행하는 현상을 시리얼 병목(serial bottleneck)이라고 합니다.

그리고 이러한 시리얼 병목이 있을 때 CPU의 코어 개수가 많아질 수록 다른 코어가 쉬는 시간은 코어 개수만큼 늘어납니다. 이러한 현상으로 인해 처리 효율성이 떨어지는 것을 암달의 법칙 또는 암달의 저주라고 한다.

이러한 암달의 저주를 줄이려면 시리얼 병목이 발생하는 구간을 최소로 줄여야 합니다.

TIP: 뮤텍스하는 부분 중에 디바이스 타임이 포함되어 있을 경우 해당 부분을 배제하고 뮤텍스를 건다.

요즘 클라이언트 개수만큼 스레드를 두면, 엄청나게 많은 컨텍스트 스위치가 일어나므로 그 대신 스레드 풀링 방법을 사용한다.

적절한 스레드 개수 지정 규칙

1. 어떤 서버의 주 역할이 CPU 연산만 하는 스레드라면(즉, 디바이스 타임이 없다면) 스레드풀의 스레드 개수는 서버의 CPU 개수와 동일하게 잡아도 충분합니다.
2. 서버에서 데이터베이스나 파일 등 다른 것에 액세스하면서 디바이스 타임이 발생할 때 스레드 개수는 CPU 개수보다 많아야 합니다.

원자 조작은 뮤텍스나 임계 영역 잠금 없이도 여러 스레드가 안전하게 접근할 수 있는 것을 의미한다.

멀티스레드 프로그래밍의 흔한 실수들

1. 읽기와 쓰기 모두에 잠금하지 않기
2. 잠금 순서 꼬임
3. 너무 좁은 잠금 범위
    1. 잠금 객체 범위가 너무 넓으면 컨텍스트 스위치가 일어날 확률이 높다.
    2. 잠금 객체 범위가 너무 좁으면 컨텍스트 스위치가 일어날 확률이 적지만, 잠금을 하는 과정과 이를 해제하는 과정에서 많은 처리 시간을 차지한다(물론 이는 디바이스 타임보다는 적다).
4. 디바이스 타임이 섞인 잠금
5. 잠금의 전염성으로 발생한 실수
6. 잠금된 뮤텍스나 critical section 삭제
7. 일관성 규칙 깨기

싱글스레드 프로세스가 다른 프로세스와 메시지를 주고받으면서 병렬 처리를 하는 모델을 일반화 한 것이 액터 모델이다.
